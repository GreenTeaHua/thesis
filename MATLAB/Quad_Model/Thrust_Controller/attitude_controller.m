function [ ] = attitude_controller( q_d )
%THRUST_CONTROLLER Implements the full saturating attitude controller
    
    global t t_s q torque_xy torque_z c_phi phi_low phi_up torques phi brake_torque v_1 v_2 d r delta_phi w s_surf_phi phi_dotv J_x q_error c_theta theta;
    
    
    i = round(t/t_s);
    
    if i > 2
    
        
        % extract the attitude error for the xy plane
        
        q_error(i,:) = quat_mult(quat_conjugate(q(i-1,:)),q_d);

        q_hat = q_error(i,:).*sign_l(q_error(4));
        
        q_zv = get_z_from_quat(q_hat);
        q_xy = quat_mult_inv(q_zv,q_hat);
        
        
        q_x = q_xy(1);
        q_y = q_xy(2);
        qp = q_xy(4);
        
        q_z = q_zv(3);
        qw = q_zv(4);
        
        % get the error between the desired thrust direction and the
        % current one
        
        phi(i) = 2*acos(qp);
        theta(i) = 2*acos(qw);
       
        
        torque_phi = 0;
        
        
        % Compute the torque field generated by the desired potential
        % energy: thrust vector will behave like a torsion spring with
        % saturation around the equilibrium and the alignment around z is
        % made at the cost of inserting 'parasitic' torques that contradict
        % the movement around a_xy or wastes control torque
        
        if qp ~= 1
            
            e_phi = 1/(sqrt(1-qp^2))*[q_x; q_y; 0];
            e_ortho = 1/(sqrt(1-qp^2))*[q_y; -q_x; 0];
            
        else
            
            e_phi = zeros(1,3);
            e_ortho = zeros(1,3);
            
        end
        
        e_z = [0; 0; 1];
        
        T_phiphi = c_phi * delta_function(phi_up,phi_low,phi(i)) * e_phi;
        T_thetaphi = -cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta * delta_integral(theta_up,theta_low,theta(i))*e_phi;
        
        if qw~=1
            T_thetaortho = q_z/sqrt(1-qw^2)*cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta*delta_function(theta_up,theta_low,theta(i))*e_ortho;
            t_thetaz = q_z/sqrt(1-qw^2)*cos(phi(i)/2)^4*c_theta*delta_function(theta_up,theta_low,theta(i))*e_z;
        else
            T_thetaortho = zeros(1,3);
            T_thetaz = zeros(1,3);
        end
        
        torque_field = T_phiphi + T_thetaphi + T_thetaortho + T_thetaz;
            
           
        
        
        
        % Compute the damping matrix
        
        
        % Compute the damping of the thrust axis: for a large error, it
        % should favor accelerations that go in ways to minimize it and
        % damp them otherwise. For a small error it should always damp the
        % movement, to allow for a smooth settling
        
        phi_dot = (phi(i)-phi(i-1))/t_s;
        
        
        % only the part of theta_dot that is in connection to w_z
        if qw ~=1
            theta_dot = -q_z/sqrt(1-qw^2)*w(i,3);
        else
            theta_dot = 0;
        end
        
        % The switching curve defines wether we should accelerate or
        % deaccelerate the axis movement
        
        
%         if v_2^2-2*(brake_torque*(phi_low-phi(i)))/J_x > 0
%             switch_curve = -sqrt(v_2^2-2*(brake_torque*(phi_low-phi(i)))/J_x);
%         else
%             switch_curve = 0;
%         end
        
        switch_curve_phi = -real(sqrt(v_2^2-2*(brake_torque*(phi_low-phi(i)))/J_x));
        
        s_surf_phi(i) = switch_curve_phi;
        phi_dotv(i) = phi_dot;
        
        
       T_phi = norm(T_phiphi)-norm(T_thetaphi);
        
        if phi_dot > v_1
            
            d_phiacc = -T_phi/phi_dot + brake_torque/phi_dot;
            
        else if phi_dot > 0 && phi_dot <= v_1
                
                d_phiacc = -T_phi/v_1 + brake_torque/v_1;
                
            else 
                
                d_phiacc = 0;
                
            end
            
        end
        
        d_phidec = -T_phi/phi_dot-brake_torque/phi_dot;
        
        d_mix = d_phiacc + (phi_dot-r*switch_curve_phi)/((1-r)*switch_curve_phi)*(d_phidec-d_phiacc);
        
        if phi_dot > r*switch_curve_phi
            
            d_phi_up = d_phiacc;
            
        else if phi_dot > switch_curve_phi && phi_dot <= r*switch_curve_phi
                
                d_phi_up = d_mix;
                
            else if phi_dot <= switch_curve_phi
                    
                    d_phi_up = d_phidec;
                    
                end
                
            end
            
        end
        
        
        d_phi_low = d;
        
        d_phi_mix = d_phi_low + (phi(i)-phi_low)/delta_phi*(d_phi_up-d_phi_low);
        
        if phi(i) < phi_low
            
            d_phi = d_phi_low;
            
        else if phi(i) >= phi_low && phi(i) < phi_low + delta_phi
                
                d_phi = d_phi_mix;
                
            else if phi(i) >= phi_low + delta_phi
                    
                    d_phi = d_phi_up;
                end
                
            end
            
        end

        if qp ~=1
            D_xy = 1/(1-qp^2)*(d_phi*[q_x^2, q_x*q_y; q_x*q_y q_y^2] + d*[q_y^2 -q_x*q_y; -q_x*q_y q_x^2]);
        else
            D_xy = [0 0; 0 0];
        
        end
        
        switch_curve_theta = - real(sqrt(v_2_theta^2
        
        
        % Compute the damping gains. Assuming c_phi was properly chosen, they will ensure that the control torques will be saturated 
        
        T_xy = zeros(2,1);
        w_xy = zeros(2,1);
        T_xy = torque_field(1:2)';
        w_xy = w(i-1,1:2)';
        
        a=D_xy(1,1)*w_xy(1)+D_xy(1,2)*w_xy(2);
        b=D_xy(2,1)*w_xy(1)+D_xy(2,2)*w_xy(2);
        
        sq = (T_xy(1)*a+T_xy(2)*b)^2-(T_xy(1)^2+T_xy(2)^2-torque_xy^2)*(a^2+b^2);
        
        if  sq < 0 || (a^2+b^2) == 0
            
            disp('aqui');
            k_1 = 1;
            
        else if sqrt(4*sq) > 2*(T_xy(1)*a+T_xy(2)*b)
                
                k_1 = (2*(T_xy(1)*a+T_xy(2)*b)+sqrt(4*sq))/(2*(a^2+b^2));
                
            else
                
                k_1 = (2*(T_xy(1)*a+T_xy(2)*b)-sqrt(4*sq))/(2*(a^2+b^2));
                
            end
            
        end
        
        if k_1 > 1
            
            k_1 = 1;
            
        else if k_1 < 0
                
                k_1 = 1;
                
            end
            
        end
        
        
        k_2 = torque_z/abs(d_z*w(i-1,3));
        
      
       if k_2 > 1
            
          k_2 = 1;
            
       end
       
       
        

        D=[k_1*D_xy, zeros(2,1); zeros(1,2) d_z*k_2];
           
        
        torques(i,:) = (torque_field-(D*w(i-1,:)')');
        
    end
    


end

