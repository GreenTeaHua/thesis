function [ ] = attitude_controller( q_d )
%THRUST_CONTROLLER Implements the full saturating attitude controller
    
    global t t_s q s_surf_theta  theta_dotv torque_xy torque_z c_phi phi_low phi_up theta_low theta_up torques phi v_1_phi v_1_theta v_2_theta v_2_phi small_delta_phi small_delta_theta r_phi r_theta delta_phi w s_surf_phi phi_dotv J_x J_z q_error c_theta theta delta_theta;
    
    
    i = round(t/t_s);
    
    if i > 2
    
        
        % extract the attitude error for the xy plane
        
       
        q_error(i,:) = quat_mult(quat_conjugate(q(i-1,:)),q_d);
        
        q_hat = q_error(i,:);
        q_hat = q_hat.*sign_l(q_hat(4));
        
        q_zv = get_z_from_quat(q_hat);
        q_xy = quat_mult_inv(q_zv,q_hat);
        
        
        q_x = q_xy(1);
        q_y = q_xy(2);
        qp = q_xy(4);
        
        q_z = q_zv(3);
        qw = q_zv(4);
        
    
        
        % get the error between the desired thrust direction and the
        % current one
        
        phi(i) = 2*acos(qp);        
        theta(i) = 2*acos(qw);
        
        if i == 3
            
            theta(:) = theta(i);
            
        end
       
        
        torque_phi = 0;
        
        
        % Compute the torque field generated by the desired potential
        % energy: thrust vector will behave like a torsion spring with
        % saturation around the equilibrium and the alignment around z is
        % made at the cost of inserting 'parasitic' torques that contradict
        % the movement around a_xy or wastes control torque
        
        if qp ~= 1
            
            e_phi = 1/(sqrt(1-qp^2))*[q_x; q_y; 0];
            e_ortho = 1/(sqrt(1-qp^2))*[q_y; -q_x; 0];
            
        else
            
            e_phi = zeros(3,1);
            e_ortho = zeros(3,1);
            
        end
        
        e_z = [0; 0; 1];
        
        T_phiphi = c_phi * delta_function(phi_up,phi_low,phi(i)) * e_phi;
        T_thetaphi = -cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta * delta_integral(theta_up,theta_low,theta(i))*e_phi;
        
        if qw~=1
            T_thetaortho = q_z/sqrt(1-qw^2)*cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta*delta_function(theta_up,theta_low,theta(i))*e_ortho;
            T_thetaz = q_z/sqrt(1-qw^2)*cos(phi(i)/2)^4*c_theta*delta_function(theta_up,theta_low,theta(i))*e_z;
        else
            T_thetaortho = zeros(3,1);
            T_thetaz = zeros(3,1);
        end
        
        
        torque_field = T_phiphi + T_thetaphi + T_thetaortho + T_thetaz;
            
           
        
        
        
        % Compute the damping matrix
        
        
        % Compute the damping of the thrust axis: for a large error, it
        % should favor accelerations that go in ways to minimize it and
        % damp them otherwise. For a small error it should always damp the
        % movement, to allow for a smooth settling
        
        phi_dot = (phi(i)-phi(i-1))/t_s;
        
        
        
        
        % The switching curve defines wether we should accelerate or
        % deaccelerate the axis movement
        
        
        switch_curve_phi = -real(sqrt(v_2_phi^2-2*(torque_xy*(phi_low-phi(i)))/J_x));
             
        s_surf_phi(i) = switch_curve_phi;
        phi_dotv(i) = phi_dot;
        
        
        
        T_phi = norm(T_phiphi)-norm(T_thetaphi);
        
        if phi_dot > v_1_phi
            
            d_phi_acc = -T_phi/phi_dot + torque_xy/phi_dot;
            
        else if phi_dot > 0 && phi_dot <= v_1_phi
                
                d_phi_acc = -T_phi/v_1_phi + torque_xy/v_1_phi;
       
            else if phi_dot <= 0
                    
                    d_phi_acc = 0;
                    
                end
                
            end
            
        end
        
        d_phi_dec = -T_phi/phi_dot - torque_xy/phi_dot;
        
        d_phi_up = xi_function(r_phi*switch_curve_phi,switch_curve_phi,phi_dot,d_phi_dec,d_phi_acc);
        
        d_phi_down = small_delta_phi;
        
        d_phi = double_xi_function(phi_up-delta_phi,phi_up,phi_low,phi_low+delta_phi,phi(i),d_phi_down,d_phi_up);
        
        % only the part of theta_dot that is in connection to w_z
        if qw ~=1
            theta_dot = -q_z/sqrt(1-qw^2)*w(i-1,3);
        else
            theta_dot = 0;
        end
        
        
        switch_curve_theta = -real(sqrt(v_2_theta^2-2*(torque_z*(theta_low-theta(i)))/J_z));  
        s_surf_theta(i) = switch_curve_theta;
        T_z = torque_field(3);
        
        d_z_acc = 0;
        
        if theta_dot > v_1_theta
            
            d_z_acc = -abs(T_z)/theta_dot + torque_z/theta_dot;
            
        else if theta_dot > 0 && theta_dot <=v_1_theta
                
                d_z_acc = -abs(T_z)/v_1_theta + torque_z/v_1_theta;
                
            else if theta_dot <= 0
                    
                    d_z_acc = 0;
                    
                end
                
            end
            
        end
        
        d_z_dec = 0;
        
        if theta_dot < - v_1_theta
            
            d_z_dec = - abs(T_z)/theta_dot - torque_z/theta_dot;
            
        else if theta_dot < 0 && theta_dot >= - v_1_theta
                
                d_z_dec = -abs(T_z)/v_1_theta - torque_z/v_1_theta;
                
            else if theta_dot >= 0
                    
                    d_z_dec = 0;
                    
                end 
                
            end
            
        end
        
        
        % the real theta_dot
        theta_dot = (theta(i)-theta(i-1))/t_s;
        
        theta_dotv(i) = theta_dot;
        
        d_z_up = xi_function(r_theta*switch_curve_theta,switch_curve_theta,theta_dot,d_z_dec,d_z_acc);
        d_z_down = small_delta_theta;
        
        d_z = xi_function(phi_up,phi_up - delta_phi,phi(i),double_xi_function(theta_up-delta_theta,theta_up,theta_low,theta_low+delta_theta,theta(i),d_z_down,d_z_up),d_z_down);
        
        d_ortho = small_delta_phi;
        

        if qp ~=1
            D_xy = 1/(1-qp^2)*(d_phi*[q_x^2, q_x*q_y; q_x*q_y q_y^2] + d_ortho*[q_y^2 -q_x*q_y; -q_x*q_y q_x^2]);
        else
            D_xy = [0 0; 0 0];
        end
        
        
        % Compute the damping gains. Assuming c_phi was properly chosen, they will ensure that the control torques will be saturated 
        
        T_xy = zeros(2,1);
        w_xy = zeros(2,1);
        T_xy = torque_field(1:2)';
        w_xy = w(i-1,1:2)';
        
        
        a = (D_xy(1,1)*w_xy(1)+D_xy(1,2)*w_xy(2))^2+(D_xy(2,1)*w_xy(1)+D_xy(2,2)*w_xy(2))^2;
        b = -2*(T_xy(1)*(D_xy(1,1)*w_xy(1)+D_xy(1,2)*w_xy(2))+T_xy(2)*(D_xy(2,1)*w_xy(1)+D_xy(2,2)*w_xy(2)));
        c = T_xy(1)^2+T_xy(2)^2-torque_xy^2;
        
        sq = b^2-4*a*c;
        
        if  sq < 0 || a == 0
            
            disp('aqui');
            k_1 = 1;
            
        else if sq > b^2
                
                k_1 = (-b+sqrt(sq))/(2*a);
                
            else
                
                k_1 = (-b-sqrt(sq))/(2*a);
                
            end
            
        end
        
        if k_1 > 1
            
            k_1 = 1;
            
        else if k_1 < 0
                
                k_1 = 1;
                
            end
            
        end
        
       w_z = w(i-1,3);
        
       a = (d_z*w_z)^2;
       b = (-2*T_z*d_z*w_z);
       c = (T_z^2-torque_z^2);
       sq = b^2-4*a*c;
       
       if sq < 0 || a == 0
           
           disp('aqui2');
           k_2 = 1;
           
       else if sq > b^2
               
               k_2 = (-b + sqrt(sq))/(2*a);
               
           else if sq <= b^2
                   
                   k_2 = (-b - sqrt(sq))/(2*a);
                   
               end
               
           end
           
       end
       
       if k_2 > 1
           
           k_2 = 1;
           
       else if k_2 < 0
               
               k_2 = 0;
               
           end
           
       end
       
       
     

       D=[k_1*D_xy, zeros(2,1); zeros(1,2) d_z*k_2];
<<<<<<< HEAD
        

=======
           
       
%        if t > 0.129 && t < 0.15
%            disp('time:');
%            disp(t);
%            disp('torque_field z:');
%            disp(torque_field(3));
%            disp('kz');
%            disp(k_2);
%            disp('d_z');
%            disp(d_z);
%            disp('damping z:');
%            disp(D(3,3));
%            disp('total field:');
%            disp(torque_field(3)-k_2*d_z*w(i-1,3));
%            
%            pause();
%            
%        end
>>>>>>> 03b2dd8d2a9c7ad2903684c3df522eef60d1bfda
        
       torques(i,:) = (torque_field'-(D*w(i-1,:)')');
       
        
    end
    


end

