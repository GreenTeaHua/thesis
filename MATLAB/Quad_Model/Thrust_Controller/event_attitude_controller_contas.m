function [ ] = attitude_controller( q_d )
%THRUST_CONTROLLER Implements the full saturating attitude controller
    
    global t t_s q ticks s_surf_theta eps_alpha lin_t_x v_dot torques_k  lin_t_y lin_t_z lin_t_p lin_t_w v_dotk D_k old_x alpha theta_dotv sigma lin_torques torque_xy torque_z c_phi phi_low phi_up theta_low theta_up torques phi v_1_phi v_1_theta v_2_theta v_2_phi small_delta_phi small_delta_theta r_phi r_theta delta_phi w s_surf_phi phi_dotv J_x J_z q_error c_theta theta delta_theta;
    
    
    i = round(t/t_s);
    
    if i > 2
    
        
        % extract the attitude error for the xy plane
        
       
        q_error(i,:) = quat_mult(quat_conjugate(q(i-1,:)),q_d);
        
        q_hat = q_error(i,:);
        q_hat = q_hat.*sign_l(q_hat(4));
        
        q_zv = get_z_from_quat(q_hat);
        q_xy = quat_mult_inv(q_zv,q_hat);
        
        
        q_x = q_xy(1);
        q_y = q_xy(2);
        q_p = q_xy(4);
        
        q_z = q_zv(3);
        q_w = q_zv(4);
        
    
        
        % get the error between the desired thrust direction and the
        % current one
        
        phi(i) = 2*acos(q_p);        
        theta(i) = 2*acos(q_w);
        
        if i == 3
            
            theta(:) = theta(i);
            
        end
       
        
        torque_phi = 0;
        
        
        % Compute the torque field generated by the desired potential
        % energy: thrust vector will behave like a torsion spring with
        % saturation around the equilibrium and the alignment around z is
        % made at the cost of inserting 'parasitic' torques that contradict
        % the movement around a_xy or wastes control torque
        
        if q_p ~= 1
            
            e_phi = 1/(sqrt(1-q_p^2))*[q_x; q_y; 0];
            e_ortho = 1/(sqrt(1-q_p^2))*[q_y; -q_x; 0];
            
        else
            
            e_phi = zeros(3,1);
            e_ortho = zeros(3,1);
            
        end
        
        e_z = [0; 0; 1];
        
        T_phiphi = c_phi * delta_function(phi_up,phi_low,phi(i)) * e_phi;
        T_thetaphi = -cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta * delta_integral(theta_up,theta_low,theta(i))*e_phi;
        
        if q_w~=1
            T_thetaortho = q_z/sqrt(1-q_w^2)*cos(phi(i)/2)^3*sin(phi(i)/2)*c_theta*delta_function(theta_up,theta_low,theta(i))*e_ortho;
            T_thetaz = q_z/sqrt(1-q_w^2)*cos(phi(i)/2)^4*c_theta*delta_function(theta_up,theta_low,theta(i))*e_z;
        else
            T_thetaortho = zeros(3,1);
            T_thetaz = zeros(3,1);
        end
        
        
        torque_field = T_phiphi + T_thetaphi + T_thetaortho + T_thetaz;
            
           
        
        
        
        % Compute the damping matrix
        
        
        % Compute the damping of the thrust axis: for a large error, it
        % should favor accelerations that go in ways to minimize it and
        % damp them otherwise. For a small error it should always damp the
        % movement, to allow for a smooth settling
        
        phi_dot = (phi(i)-phi(i-1))/t_s;
        
        
        
        
        % The switching curve defines wether we should accelerate or
        % deaccelerate the axis movement
        
        
        switch_curve_phi = -real(sqrt(v_2_phi^2-2*(torque_xy*(phi_low-phi(i)))/J_x));
             
        s_surf_phi(i) = switch_curve_phi;
        phi_dotv(i) = phi_dot;
        
        
        
        T_phi = norm(T_phiphi)-norm(T_thetaphi);
        
        if phi_dot > v_1_phi
            
            d_phi_acc = -T_phi/phi_dot + torque_xy/phi_dot;
            
        else if phi_dot > 0 && phi_dot <= v_1_phi
                
                d_phi_acc = -T_phi/v_1_phi + torque_xy/v_1_phi;
       
            else if phi_dot <= 0
                    
                    d_phi_acc = 0;
                    
                end
                
            end
            
        end
        
        d_phi_dec = -T_phi/phi_dot - torque_xy/phi_dot;
        
        d_phi_up = xi_function(r_phi*switch_curve_phi,switch_curve_phi,phi_dot,d_phi_dec,d_phi_acc);
        
        d_phi_down = small_delta_phi;
        
        d_phi = double_xi_function(phi_up-delta_phi,phi_up,phi_low,phi_low+delta_phi,phi(i),d_phi_down,d_phi_up);
        
        % only the part of theta_dot that is in connection to w_z
        if q_w ~=1
            theta_dot = -q_z/sqrt(1-q_w^2)*w(i-1,3);
        else
            theta_dot = 0;
        end
        
        
        switch_curve_theta = -real(sqrt(v_2_theta^2-2*(torque_z*(theta_low-theta(i)))/J_z));  
        s_surf_theta(i) = switch_curve_theta;
        T_z = torque_field(3);
        
        d_z_acc = 0;
        
        if theta_dot > v_1_theta
            
            d_z_acc = -abs(T_z)/theta_dot + torque_z/theta_dot;
            
        else if theta_dot > 0 && theta_dot <=v_1_theta
                
                d_z_acc = -abs(T_z)/v_1_theta + torque_z/v_1_theta;
                
            else if theta_dot <= 0
                    
                    d_z_acc = 0;
                    
                end
                
            end
            
        end
        
        d_z_dec = 0;
        
        if theta_dot < - v_1_theta
            
            d_z_dec = - abs(T_z)/theta_dot - torque_z/theta_dot;
            
        else if theta_dot < 0 && theta_dot >= - v_1_theta
                
                d_z_dec = -abs(T_z)/v_1_theta - torque_z/v_1_theta;
                
            else if theta_dot >= 0
                    
                    d_z_dec = 0;
                    
                end 
                
            end
            
        end
        
        
        % the real theta_dot
        theta_dot = (theta(i)-theta(i-1))/t_s;
        
        theta_dotv(i) = theta_dot;
        
        d_z_up = xi_function(r_theta*switch_curve_theta,switch_curve_theta,theta_dot,d_z_dec,d_z_acc);
        d_z_down = small_delta_theta;
        
        d_z = xi_function(phi_up,phi_up - delta_phi,phi(i),double_xi_function(theta_up-delta_theta,theta_up,theta_low,theta_low+delta_theta,theta(i),d_z_down,d_z_up),d_z_down);
        
        d_ortho = small_delta_phi;
        

        if q_p ~=1
            D_xy = 1/(1-q_p^2)*(d_phi*[q_x^2, q_x*q_y; q_x*q_y q_y^2] + d_ortho*[q_y^2 -q_x*q_y; -q_x*q_y q_x^2]);
        else
            D_xy = [0 0; 0 0];
        end
        
        
        % Compute the damping gains. Assuming c_phi was properly chosen, they will ensure that the control torques will be saturated 
        
        T_xy = zeros(2,1);
        w_xy = zeros(2,1);
        T_xy = torque_field(1:2)';
        w_xy = w(i-1,1:2)';
        
        
        a = (D_xy(1,1)*w_xy(1)+D_xy(1,2)*w_xy(2))^2+(D_xy(2,1)*w_xy(1)+D_xy(2,2)*w_xy(2))^2;
        b = -2*(T_xy(1)*(D_xy(1,1)*w_xy(1)+D_xy(1,2)*w_xy(2))+T_xy(2)*(D_xy(2,1)*w_xy(1)+D_xy(2,2)*w_xy(2)));
        c = T_xy(1)^2+T_xy(2)^2-torque_xy^2;
        
        sq = b^2-4*a*c;
        
        if  sq < 0 || a == 0
            
            k_1 = 1;
            
        else if sq > b^2
                
                k_1 = (-b+sqrt(sq))/(2*a);
                
            else
                
                k_1 = (-b-sqrt(sq))/(2*a);
                
            end
            
        end
        
        if k_1 > 1
            
            k_1 = 1;
            
        else if k_1 < 0
                
                k_1 = 1;
                
            end
            
        end
        
       w_z = w(i-1,3);
        
       a = (d_z*w_z)^2;
       b = (-2*T_z*d_z*w_z);
       c = (T_z^2-torque_z^2);
       sq = b^2-4*a*c;
       
       if sq < 0 || a == 0
           k_2 = 1;
           
       else if sq > b^2
               
               k_2 = (-b + sqrt(sq))/(2*a);
               
           else if sq <= b^2
                   
                   k_2 = (-b - sqrt(sq))/(2*a);
                   
               end
               
           end
           
       end
       
       if k_2 > 1
           
           k_2 = 1;
           
       else if k_2 < 0
               
               k_2 = 0;
               
           end
           
       end
       
       
     

       D=[k_1*D_xy, zeros(2,1); zeros(1,2) d_z*k_2];
           
       
%        if t > 0.129 && t < 0.15
%            disp('time:');
%            disp(t);
%            disp('torque_field z:');
%            disp(torque_field(3));
%            disp('kz');
%            disp(k_2);
%            disp('d_z');
%            disp(d_z);
%            disp('damping z:');
%            disp(D(3,3));
%            disp('total field:');
%            disp(torque_field(3)-k_2*d_z*w(i-1,3));
%            
%            pause();
%            
%        end
        
       %event triggering function
    
     
    
    w_error = w(i-1,:) - old_x(6:8);
    q_x_error = q_x - old_x(1);
    q_y_error = q_y - old_x(2);
    q_z_error = q_z - old_x(3);
    q_p_error = q_z - old_x(4);
    q_w_error = q_w - old_x(5);
    
    v_dot(i) = w(i-1,:)*torques_k - torque_field'*w(i-1,:)';
    
    lin_torques = lin_t_x.*q_x_error+lin_t_y.*q_y_error+lin_t_z.*q_z_error+lin_t_p.*q_p_error+lin_t_w.*q_w_error;
    
    if v_dotk ~= 0
        alpha = w(i-1,:)*lin_torques + w_error*D_k*old_x(6:8)';
    else
        alpha = 0;
    end
    
   
    if isnan(alpha)
        alpha = v_dotk;
        disp('nan');
    end
   
    %alpha = v_dotk;
    
    if  alpha <= v_dotk
       
       D_k = D;
       v_dotk = -w(i-1,:)*D*w(i-1,:)';
       torques(i,:) = (torque_field'-(D*w(i-1,:)')');
       torques_k = torques(i,:)'; % for debug
       ticks(i) = 1; 
       old_x = [q_x, q_y, q_z, q_p, q_w ,w(i-1,:)];
       
       
       % Compute new linearization
       A = sqrt(1-q_w^2);
       B = c_theta * delta_integral(theta_up,theta_low,theta(i));
       C = c_phi / sqrt(1-q_p^2);
       
       D = c_theta / A;
       E = acos(q_w);
       F = acos(q_p);
       
       lin_t_x = [C * delta_function(phi_up,phi_low,phi(i)) - q_p^3*B;
                  -q_z*q_p^3*D*delta_function(theta_up,theta_low,theta(i));
                  0];
       lin_t_y = [q_z*q_p^3*D*delta_function(theta_up,theta_low,theta(i));
                  C * delta_function(phi_up,phi_low,phi(i)) - q_p^3*B;
                  0];
       lin_t_z = [q_y*q_p^3*D*delta_function(theta_up,theta_low,theta(i));
                  q_x*q_p^3*D*delta_function(theta_up,theta_low,theta(i));
                  q_p^4*D*delta_function(theta_up,theta_low,theta(i))];
              
       if phi(i) >= 0 && phi(i) < phi_low
           
           lin_t_p = [(-4*C*F/A+q_p*C/A^2-3*q_p^2*B)*q_x + 3*q_z*q_y*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                      (-4*C*F/A+q_p*C/A^2-2*C-3*q_p^2*B)*q_y - 3*q_z*q_x*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                      4*q_z*q_p^3*D*delta_function(theta_up,theta_low,theta(i))];
                  
       else if phi(i) >= phi_low && phi(i) < phi_up
               
               lin_t_p = [(phi_low*C-3*q_p^2*B)*q_x + 3*q_z*q_y*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                          (phi_low*C-3*q_p^2*B)*q_y - 3*q_z*q_x*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                          4*q_z*q_p^3*D*delta_function(theta_up,theta_low,theta(i))];
                      
           else if phi(i) >= phi_up  && phi(i) <= pi
                   
                   lin_t_p = [(C*phi_low*q_p*(2*F-pi)/(A^2*(phi_up-pi))-2*C*phi_low/(A*(phi_up-pi))-3*q_p^2*B)*q_x + 3*q_z*q_y*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                              (C*phi_low*q_p*(2*F-pi)/(A^2*(phi_up-pi))-2*C*phi_low/(A*(phi_up-pi))-3*q_p^2*B)*q_y - 3*q_z*q_x*q_p^2*D*delta_function(theta_up,theta_low,theta(i));
                              4*q_z*q_p^3*D*delta_function(theta_up,theta_low,theta(i))];
                          
               end
               
           end
           
       end
       
       if theta(i) >= 0 && theta(i) < theta_low
           
           lin_t_w = [4*q_p^3*q_x*D + 2*q_w*q_z*q_p^3*q_y*D*E/A^2 - 2*q_z*q_p^3*q_y*C/A;
                      4*q_p^3*q_y*D - 2*q_w*q_z*q_p^3*q_x*D*E/A^2 + 2*q_z*q_p^3*q_x*C/A;
                      2*q_z*q_p^4*q_w*D*E/A^2 - 2*q_z*q_p^4*D/A];
                  
       else if theta(i) >= theta_low && theta(i) < theta_up
               
               lin_t_w = [2*theta_low*q_p^3*q_x*D+theta_low*q_w*q_z*q_p^3*q_y*(2*E-theta_low)*D/A^2 - 2*theta_low*q_z*q_p^3*q_y*D/A;
                          2*theta_low*q_p^3*q_y*D-theta_low*q_w*q_z*q_p^3*q_x*(2*E-theta_low)*D/A^2 + 2*theta_low*q_z*q_p^3*q_x*D/A;
                          theta_low*q_z*q_p^4*q_w*(2*E-theta_low)*D/A^2-2*theta_low*q_z*q_p^4*D/A];
           else if theta(i) >= theta_up && theta(i) <= pi
                   
                   lin_t_w = [-theta_low*q_p^3*q_x*(2*pi-4*E)*D/(phi_up-pi) + phi_low*q_w*q_z*q_p^3*q_y*(2*E-pi)*D/((phi_up-pi)*A^2) - 2*phi_low*q_z*q_p^3*q_y*D/((phi_up-pi)*A);
                              -theta_low*q_p^3*q_y*(2*pi-4*E)*D/(phi_up-pi) - phi_low*q_w*q_z*q_p^3*q_x*(2*E-pi)*D/((phi_up-pi)*A^2) + 2*phi_low*q_z*q_p^3*q_x*D/((phi_up-pi)*A);
                              phi_low*q_z*q_p^4*q_w*(2*E-pi)*D/((phi_up-pi)*A^2)-2*phi_low*q_z*q_p^4*D/((phi_up-pi)*A)];
               end
           end
       end
       
       
               
    else % No triggering
           
           torques(i,:) = torques(i-1,:);
    end
    


end

